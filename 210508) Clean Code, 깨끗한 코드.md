### 1) 코드가 존재하리라
**코드는 요구사항을 상세히하는 수단이다.**

  * 어느 정도 수준에 이르면 코드의 도움없이는 요구사항을 상세히 표현하기란 불가능에 가깝다.
   * 코드는 **정밀한 표현**이다.
  * 고도로 추상화된 언어나 특정 응용 분야 언어로 기술하는 명세 역시 코드이다.
  <br >

### 2) 나쁜 코드

우리 모두는 **좋은 코드가 중요**하다는 사실을 안다.
 * 나쁜 코드는 프로그램을 확장해갈수록 생산성을 낮추며 결국 0에 근접한다.
 * 이는 결국 회사를 망하게 하는 원인이 된다.
 <br >
#### 어째서 나쁜 코드를 짰는가?
 * 시간에 밀려 쓰레기 같더라도 실행되는 코드를 우선 만들어 출시하는데 목적을 두는 경우
 * 나쁜 코드는 결국 고칠 때 마다 새로운 문제점들이 나온다.
 * 기능을 추가할 때 마다 나쁜코드는 새로운 나쁜코드를 만들게 한다.

 <br >

**르블랑의 법칙(leblanc's Law)**: **나중은 결코 오지 않는다.**

**빨리 가는 유일한 방법은 제대로 가는 것이다.**


<br >

### 3) 나쁜 코드로 치루게 되는 대가


**나쁜 코드가 쌓일수록 팀 생산성은 떨어지며 결국 개발속도를 크게 떨어뜨린다.**

나쁜 코드는 나쁜 코드를 양산하게 만들며, 결국 프로그래머가 다시 만들면 더 잘 만들수 있다는 오만에 빠지게 한다.

원대한 재설계의 꿈을 키워서 다시 만든다해도 새로운 타이거팀은 현재 프로그램에 있는 기능들 구현과 현재 사용되는 프로그램에서 새로 도입될 기능들 역시 새로운 프로그램내에서 구현해야한다.

이는 결국 새로운 팀을 만들기 위해 추가 자원을 소모하게 된다는거고 현재 사용되는 프로그램은 계속해서 기능이 추가 될 것이기 때문에 새로운 프로그램이 이를 따라가기 위해 해야할 일은 점점 늘어날 것이고 결국 개발하는데 필요한 기간은 점점 늘어갈 것이다. 최종적으로 회사와 팀 모두가 지쳐갈 것이다.**텍스트**

**결국 빨리 가는 유일한 방법은 제대로 가는 것이다.**

<br >

### 4) 원초적 난제

> 프로그래머는 누구나 나쁜 코드가 결국 속도를 늦춘다는 사실을 알고있다.
그럼에도 기한을 맞추려면 나쁜 코드를 양산할 수 밖에 없다고 느끼게된다.
간단히 말해, **빨리 가기 위해 시간을 들이지 않는다.**

사실 나쁜 코드를 양산할수 밖에 없다는 생각과 전제는 틀렸다. 나쁜 코드를 양산하는 것은 결과적으로 기한을 맞추지 못한다. 오히려 프로그램은 점점 엉망이 될것이고, 그로 인해 개발 속도가 곧바로 늦어지게 되고 결국 기한을 맞추지 못하게 된다.

**결국 빨리 가는 방법은 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.**
<br >

### 5) 보이스카우트 규칙
> **"처음 왔을 때보다 더 나은 세상을 만들고 떠나려 노력하라" **
-로버트 베이든 파월 (스카우트 운동 창립자)-

처음 시작할 때보다 좀 더 깨끗한 코드를 끝날 때 만들었다면 코드는 점점 개선된다.

시간이 지날수록 **좋아지는** 프로젝트.

**즉, 지속적인 개선이 전문가 정신의 본질이다.**
<br >
### 6) 객체 지향 설계의 다섯가지 원칙
**SRP (The Single Reponsibility Principle)**
단일 책임의 원칙
클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다.

**OCP (The Open Closed Principle)**
개방 폐쇄의 원칙
클래스는 확장에 열려있어야하며, 변경에 닫혀있어야 한다.

**LSP (The Liskov Substitution Principle)**
리스코프의 치환 법칙
상속받은 클래스는 기초 클래스를 대체할 수 있어야 한다.

**DIP (The Dependency Inversion Principle)**
의존 역전의 법칙
추상화에 의존해야하며, 구체화에 의존하면 안된다.

**ISP (The Interface Segregation Principle)**
인터페이스 분리 원칙
클라이언트에 밀접하게 작게 쪼개진 인터페이스를 유지한다.
